# Geocode and map newspaper titles
R is also really good for creating maps, both for visualisations and for spatial analysis. 



## Points
Another thing we can do is create a map of all the titles. For this we'll need three things

* A background map of the UK and Ireland

* A count of the total titles for each city

* A list of coordinates for all the cities. This last one is a little trickier than the other two, as I'll explain. Without some manually editing we might end up with some slightly dodgy results. But let's just see where we end up.

### Drawing a background map. `

Maps is a library for R which, unsurprisingly, contains some map data, including some high resolution maps of the world. To draw the map, first we install the library. 


```install.packages('maps')```

Next we load two libraries to use: maps and ggplot2. We'll use a function from ggplot2 called ```map_data``` to turn some data from the maps package into a dataframe, and then we'll use some more plotting functions from ggplot2 to draw the map. 

```{r}
library(ggplot2)
library(maps)
```
First we assign a name to the dataframe we'll create with ```map_data```

```{r}
worldmap = map_data('world')
```
Take a look at the dataframe we've created:

```{r}
head(worldmap, 20)
```

It's a big table with about 100,000 rows. Each row has a latitude and longitude, and a group. Each region and sub-region in the dataframe has its own group number. We'll use a function ```geom_polygon``` which tells ggplot to draw a polygon (a bunch of connected lines) for each group, and display it.

With the ```aes()```, x tells ggplot2 the longitude of each point, y the latitude, and group makes sure the polygons are grouped together correctly. 

```{r}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group))
```

Right, it needs a _bit_ of tweaking. First, we only want to plot points in the UK and Ireland. There's obviously way too much map for this, so the first thing we should do is restrict it to a rectangle which includes those two countries. 

We can do that with ```coord_fixed()```. ```coord_fixed()``` is used to fix the aspect ratio of a coordinate system, but can be used to specify a bounding box by using two of its arguments: ```xlim=``` and ```ylim=```. These each take a vector (a series of numbers) with two numbers. A vector is created using ```c()```. Each number specifies the limits for that axis. So ```xlim = c(0,10)``` means _restrict the x-axis to 0 and 10_. The axes correspond to the lines of longitude (x) and latitude (y). We'll restrict the x-axis to c(-10, 4) and the y-axis to c(54, 60) which should just about cover the UK and Ireland. 

```{r}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group)) + 
  coord_fixed(xlim = c(-10,3), ylim = c(50, 59))
```


We can also change the ratio of the coordinates using ```coord_fixed()```. The default is 1, but by specifying a different one with the argument ```ratio =```, that can be changed. Using ```ratio = 1.3``` results in a less squashed-looking map. 


```{r}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group)) + 
  coord_fixed(ratio = 1.3, xlim = c(-10,3), ylim = c(50, 59))
```

A couple more things, which I'll run through quickly.

We can specify fill and line colors usings ```fill = ``` and ```color = ``` inside ```geom_polygon()``` but _outside_ ```aes()```. 

```{r}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group), fill = 'gray90', color = 'black') + 
  coord_fixed(ratio = 1.3, xlim = c(-10,3), ylim = c(50, 59))
```

We probably don't need the grids or panels in the background. We can get rid of these with ```+ theme_void()```, but bear in mind we might need to add some theme elements back, manually.


```{r}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group), fill = 'gray90', color = 'black') + 
  coord_fixed(ratio = 1.3, xlim = c(-10,3), ylim = c(50, 59)) + 
  theme_void()
```

### Get a count of the total titles for each city

This next bit uses some of the functions demonstrated in the introduction to R and the tidyverse, namely ```group_by()``` and ```tally()```. 

First load the rest of the tidyverse packages. 

```{r message=FALSE, warning=FALSE}
library(tidyverse)
```

Next, load the title list, which can be dowloaded here: 

```{r message=FALSE, warning=FALSE}
title_list = read_csv('data/BritishAndIrishNewspapersTitleList_20191118.csv')
```

We can quite easily make a new data frame, which will just include each location and the total number of instances in the dataset.


```{r}
location_counts = title_list %>% 
  group_by(country_of_publication, general_area_of_coverage, coverage_city) %>% 
  tally()
```

Arranging these in descending order of their count shows how many of each we have:

```{r}
location_counts %>% 
  arrange(desc(n))
```

### Get a list of points. 

Well, we've cheated and made this one already, with lots of manual work. 

We'll load a dataset containing geocorrected points

```{r message=FALSE, warning=FALSE}
geocorrected = read_csv('data/geocorrected.csv')
```

This needs a little bit of pre-processing. First use a library called ```snakecase``` and a function called ```to_snakecase()``` to standardise the column names.  

```{r}
library(snakecase)
colnames(geocorrected)  = to_snake_case(colnames(geocorrected))
```

Then make the coordinate columns numeric using ```mutate()```

```{r}
geocorrected = geocorrected %>%
  mutate(wikilat = as.numeric(wikilat)) %>% 
  mutate(wikilon = as.numeric(wikilon))
```

Last, change the NA values to the same format as the ones in the title list. 
```{r}
geocorrected = geocorrected %>% 
  mutate(country_of_publication = replace(country_of_publication, country_of_publication == 'na', NA)) %>% mutate(general_area_of_coverage = replace(general_area_of_coverage, general_area_of_coverage == 'na', NA)) %>% 
  mutate(coverage_city = replace(coverage_city, coverage_city == 'na', NA))
```


Using ```left_join()``` we will merge these dataframes, joining up each set of location information to its coordinates and standardised name. 

```{r}
lc_with_geo = location_counts %>% left_join(geocorrected, by = c('coverage_city' ,'general_area_of_coverage', 'country_of_publication'))
```

Right, now we're going to use ```group_by()``` and ```tally()``` again, this time on the the wikititle, wikilat and wikilon columns. This is because the wikititle is a standardised title, which means it will group together cities properly, rather than giving a different row for slightly different combinations of the three geographic information columns. 

```{r}
lc_with_geo_counts = lc_with_geo %>% group_by(wikititle, wikilat, wikilon) %>% tally(n)
```

OK, lc_with_geo_counts is what we want to plot. This contains the city title, coordinates and counts for all the relevant places in our dataset. But first we again need the map we created earlier. 

```{r}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group), fill = 'gray90', color = 'black') + 
  coord_fixed(ratio = 1.3, xlim = c(-10,3), ylim = c(50, 59)) + 
  theme_void()
```

Now we will plot the cities using ```geom_point()``` We'll specify the ```lc_with_geo_counts``` as the argument to ```data = ``` within ```geom_point()```. The x axis position of each point is the longitude, and the y axis the latitude. We'll also use the argument ```size = n``` within the ```aes()```, to tell ggplot2 to size the points by the column n, which contains the counts for each of our locations, and the argument ```alpha = .7``` outside the ```aes()```, to make the points more transparent and slightly easier to read overlapping ones. 

One last thing we'll add is ```+scale_size_area()```. This sizes the points using their radius rather than diameter, which is a more correct way of representing numbers using circles!

```{r warning=FALSE}
ggplot() + geom_polygon(data = worldmap, aes(x = long, y = lat, group = group), fill = 'gray90', color = 'black') + 
  coord_fixed(ratio = 1.3, xlim = c(-10,3), ylim = c(50, 59)) + 
  theme_void() + geom_point(data = lc_with_geo_counts, aes(x = as.numeric(wikilon), y = as.numeric(wikilat), size = n), alpha = .7) + 
  scale_size_area()
```


## Choropleth map

### Which libraries are needed
```{r message=FALSE, warning=FALSE}
library(sf)
library(rgdal)
library(broom)
library(rgeos)
```



### Download a shapefile

[From here](https://data.gov.uk/dataset/0fb911e4-ca3a-4553-9136-c4fb069546f9/ceremonial-county-boundaries-of-england)

### Have a look at the shapefile

```{r}
england_shp = readOGR(dsn = "data/english_ceremonial_counties", layer = "English Ceremonial Counties")
```
The next thing to do is use a library called broom and a function called ```tidy()```. This turns the shapefile into a dataframe which can be read and plotted by ggplot2. 

First change the projection:

```{r}
pc <- spTransform( england_shp, CRS( "+init=EPSG:4326" ) ) 
```

Then use ```gSimplify()``` to simplify it very slightly:

```{r}
pc <- gSimplify(pc, tol = 0.00001)
```

```{r warning=FALSE}
pc_tidy = broom::tidy(pc, region = 'NAME')
```

Add back in the data, which gSimplify doesn't keep:

```{r}
pc_df <- england_shp@data
pc <- sp::SpatialPolygonsDataFrame(pc, pc_df)
```

Finally, do the tidy again. It should work this time. 

```{r warning=FALSE}
pc_tidy = broom::tidy(pc, region = 'NAME')
```

https://gis.stackexchange.com/questions/243569/simplify-polygons-of-sf-object

```{r}
county_totals = title_list %>% 
  group_by(general_area_of_coverage) %>% 
  tally()
```

```{r warning=FALSE}
pc_tidy = broom::tidy(pc, region = 'NAME')
```

Draw the map:
```{r}
ggplot() + 
  geom_polygon(data = pc_tidy, aes(x = long, y = lat, group = group))
```

Add in the counts using ```left_join()```

```{r}
ggplot() + 
  geom_polygon(data = pc_tidy %>% 
                 left_join(county_totals, 
                           by = c('id' = 'general_area_of_coverage')), 
               aes(x = long, y = lat, 
                   fill = n, group = group)) + 
  theme_void() + 
  coord_fixed(1.3) + scale_fill_viridis_c()
```

```{r}
anti_join(title_list %>% 
            filter(country_of_publication == 'England') %>% 
            group_by(general_area_of_coverage) %>% 
            tally(),pc_tidy %>% 
            group_by(id) %>% 
            tally() %>% 
            select(id), by = c('general_area_of_coverage' = 'id')) %>% 
  arrange(desc(n))
```
```{r}
anti_join(pc_tidy %>% group_by(id) %>% tally() %>% select(id),title_list %>% filter(country_of_publication == 'England') %>% group_by(general_area_of_coverage) %>% tally(), by = c('id' = 'general_area_of_coverage')) 

```

```{r}
knitr::kable(
  head(mtcars[, 1:8], 10), booktabs = TRUE,
  caption = 'A table of the first 10 rows of the mtcars data.'
)
```


### Count the general area of coverage field

### Change some of the names to fit the shapefile

### 